import c from 'tinyrainbow';
import { isFileServingAllowed, getFilePoolName, distDir, resolveApiServerConfig, resolveFsAllow, createDebugger, isValidApiRequest, createViteLogger, createViteServer } from 'vitest/node';
import fs, { promises, readFileSync, lstatSync, existsSync } from 'node:fs';
import { createRequire } from 'node:module';
import { dynamicImportPlugin, ServerMockResolver } from '@vitest/mocker/node';
import { slash, toArray, createDefer } from '@vitest/utils';
import MagicString from 'magic-string';
import sirv from 'sirv';
import { coverageConfigDefaults } from 'vitest/config';
import { fileURLToPath } from 'node:url';
import { P as PlaywrightBrowserProvider, W as WebdriverBrowserProvider } from './webdriver-Cv9wga63.js';
import { resolve as resolve$1, dirname as dirname$1, basename as basename$1, normalize as normalize$1 } from 'node:path';
import { mkdir, readFile as readFile$1 } from 'node:fs/promises';
import crypto from 'node:crypto';
import { WebSocketServer } from 'ws';
import { parseErrorStacktrace, parseStacktrace } from '@vitest/utils/source-map';
import * as nodeos from 'node:os';

var version = "2.1.9";

const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}

const _UNC_REGEX = /^[/\\]{2}/;
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
const _ROOT_FOLDER_RE = /^\/([A-Za-z]:)?$/;
const normalize = function(path) {
  if (path.length === 0) {
    return ".";
  }
  path = normalizeWindowsPath(path);
  const isUNCPath = path.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute(path);
  const trailingSeparator = path[path.length - 1] === "/";
  path = normalizeString(path, !isPathAbsolute);
  if (path.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path += "/";
  }
  if (_DRIVE_LETTER_RE.test(path)) {
    path += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path}`;
    }
    return `//${path}`;
  }
  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;
};
const join = function(...arguments_) {
  if (arguments_.length === 0) {
    return ".";
  }
  let joined;
  for (const argument of arguments_) {
    if (argument && argument.length > 0) {
      if (joined === void 0) {
        joined = argument;
      } else {
        joined += `/${argument}`;
      }
    }
  }
  if (joined === void 0) {
    return ".";
  }
  return normalize(joined.replace(/\/\/+/g, "/"));
};
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
const resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path = index >= 0 ? arguments_[index] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};
const _EXTNAME_RE = /.(\.[^./]+)$/;
const extname = function(p) {
  const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));
  return match && match[1] || "";
};
const relative = function(from, to) {
  const _from = resolve(from).replace(_ROOT_FOLDER_RE, "$1").split("/");
  const _to = resolve(to).replace(_ROOT_FOLDER_RE, "$1").split("/");
  if (_to[0][1] === ":" && _from[0][1] === ":" && _from[0] !== _to[0]) {
    return _to.join("/");
  }
  const _fromCopy = [..._from];
  for (const segment of _fromCopy) {
    if (_to[0] !== segment) {
      break;
    }
    _from.shift();
    _to.shift();
  }
  return [..._from.map(() => ".."), ..._to].join("/");
};
const dirname = function(p) {
  const segments = normalizeWindowsPath(p).replace(/\/$/, "").split("/").slice(0, -1);
  if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {
    segments[0] += "/";
  }
  return segments.join("/") || (isAbsolute(p) ? "/" : ".");
};
const basename = function(p, extension) {
  const lastSegment = normalizeWindowsPath(p).split("/").pop();
  return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
};

const pkgRoot = resolve(fileURLToPath(import.meta.url), "../..");
const distRoot = resolve(pkgRoot, "dist");

const clear = async (context, selector) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const { iframe } = context;
    const element = iframe.locator(selector);
    await element.clear({
      timeout: 1e3
    });
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    const element = await browser.$(selector);
    await element.clearValue();
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support clearing elements`);
  }
};

const click = async (context, selector, options = {}) => {
  const provider = context.provider;
  if (provider instanceof PlaywrightBrowserProvider) {
    const tester = context.iframe;
    await tester.locator(selector).click({
      timeout: 1e3,
      ...options
    });
  } else if (provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    await browser.$(selector).click(options);
  } else {
    throw new TypeError(`Provider "${provider.name}" doesn't support click command`);
  }
};
const dblClick = async (context, selector, options = {}) => {
  const provider = context.provider;
  if (provider instanceof PlaywrightBrowserProvider) {
    const tester = context.iframe;
    await tester.locator(selector).dblclick(options);
  } else if (provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    await browser.$(selector).doubleClick();
  } else {
    throw new TypeError(`Provider "${provider.name}" doesn't support dblClick command`);
  }
};
const tripleClick = async (context, selector, options = {}) => {
  const provider = context.provider;
  if (provider instanceof PlaywrightBrowserProvider) {
    const tester = context.iframe;
    await tester.locator(selector).click({
      timeout: 1e3,
      ...options,
      clickCount: 3
    });
  } else if (provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    await browser.action("pointer", { parameters: { pointerType: "mouse" } }).move({ origin: await browser.$(selector) }).down().up().pause(50).down().up().pause(50).down().up().pause(50).perform();
  } else {
    throw new TypeError(`Provider "${provider.name}" doesn't support tripleClick command`);
  }
};

const dragAndDrop = async (context, source, target, options_) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const frame = await context.frame();
    await frame.dragAndDrop(
      source,
      target,
      {
        timeout: 1e3,
        ...options_
      }
    );
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const $source = context.browser.$(source);
    const $target = context.browser.$(target);
    const options = options_ || {};
    const duration = options.duration ?? 10;
    await context.browser.action("pointer").move({ duration: 0, origin: $source, x: options.sourceX ?? 0, y: options.sourceY ?? 0 }).down({ button: 0 }).move({ duration: 0, origin: "pointer", x: 0, y: 0 }).pause(duration).move({ duration: 0, origin: $target, x: options.targetX ?? 0, y: options.targetY ?? 0 }).move({ duration: 0, origin: "pointer", x: 1, y: 0 }).move({ duration: 0, origin: "pointer", x: -1, y: 0 }).up({ button: 0 }).perform();
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support dragging elements`);
  }
};

const fill = async (context, selector, text, options = {}) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const { iframe } = context;
    const element = iframe.locator(selector);
    await element.fill(text, { timeout: 1e3, ...options });
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    await browser.$(selector).setValue(text);
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support clearing elements`);
  }
};

const types = { "application/andrew-inset": ["ez"], "application/appinstaller": ["appinstaller"], "application/applixware": ["aw"], "application/appx": ["appx"], "application/appxbundle": ["appxbundle"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/automationml-aml+xml": ["aml"], "application/automationml-amlx+zip": ["amlx"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cpl+xml": ["cpl"], "application/cu-seeme": ["cu"], "application/cwl": ["cwl"], "application/dash+xml": ["mpd"], "application/dash-patch+xml": ["mpp"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdf": ["fdf"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["*js"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/media-policy-dataset+xml": ["mpf"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["*mp4", "*mpg4", "mp4s", "m4p"], "application/msix": ["msix"], "application/msixbundle": ["msixbundle"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-keys": ["asc"], "application/pgp-signature": ["sig", "*asc"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/sql": ["sql"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/watcherinfo+xml": ["wif"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xfdf": ["xfdf"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/aac": ["adts", "aac"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avci": ["avci"], "image/avcs": ["avcs"], "image/avif": ["avif"], "image/bmp": ["bmp", "dib"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/dpx": ["dpx"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm", "jpgm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/jt": ["jt"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/prc": ["prc"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/u3d": ["u3d"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/javascript": ["js", "mjs"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["md", "markdown"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/wgsl": ["wgsl"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "*jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
Object.freeze(types);

var __classPrivateFieldGet = (null && null.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Mime_extensionToType, _Mime_typeToExtension, _Mime_typeToExtensions;
class Mime {
    constructor(...args) {
        _Mime_extensionToType.set(this, new Map());
        _Mime_typeToExtension.set(this, new Map());
        _Mime_typeToExtensions.set(this, new Map());
        for (const arg of args) {
            this.define(arg);
        }
    }
    define(typeMap, force = false) {
        for (let [type, extensions] of Object.entries(typeMap)) {
            type = type.toLowerCase();
            extensions = extensions.map((ext) => ext.toLowerCase());
            if (!__classPrivateFieldGet(this, _Mime_typeToExtensions, "f").has(type)) {
                __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").set(type, new Set());
            }
            const allExtensions = __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type);
            let first = true;
            for (let extension of extensions) {
                const starred = extension.startsWith('*');
                extension = starred ? extension.slice(1) : extension;
                allExtensions?.add(extension);
                if (first) {
                    __classPrivateFieldGet(this, _Mime_typeToExtension, "f").set(type, extension);
                }
                first = false;
                if (starred)
                    continue;
                const currentType = __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(extension);
                if (currentType && currentType != type && !force) {
                    throw new Error(`"${type} -> ${extension}" conflicts with "${currentType} -> ${extension}". Pass \`force=true\` to override this definition.`);
                }
                __classPrivateFieldGet(this, _Mime_extensionToType, "f").set(extension, type);
            }
        }
        return this;
    }
    getType(path) {
        if (typeof path !== 'string')
            return null;
        const last = path.replace(/^.*[/\\]/, '').toLowerCase();
        const ext = last.replace(/^.*\./, '').toLowerCase();
        const hasPath = last.length < path.length;
        const hasDot = ext.length < last.length - 1;
        if (!hasDot && hasPath)
            return null;
        return __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(ext) ?? null;
    }
    getExtension(type) {
        if (typeof type !== 'string')
            return null;
        type = type?.split?.(';')[0];
        return ((type && __classPrivateFieldGet(this, _Mime_typeToExtension, "f").get(type.trim().toLowerCase())) ?? null);
    }
    getAllExtensions(type) {
        if (typeof type !== 'string')
            return null;
        return __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type.toLowerCase()) ?? null;
    }
    _freeze() {
        this.define = () => {
            throw new Error('define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances');
        };
        Object.freeze(this);
        for (const extensions of __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").values()) {
            Object.freeze(extensions);
        }
        return this;
    }
    _getTestState() {
        return {
            types: __classPrivateFieldGet(this, _Mime_extensionToType, "f"),
            extensions: __classPrivateFieldGet(this, _Mime_typeToExtension, "f"),
        };
    }
}
_Mime_extensionToType = new WeakMap(), _Mime_typeToExtension = new WeakMap(), _Mime_typeToExtensions = new WeakMap();

var mime = new Mime(types)._freeze();

function assertFileAccess(path, project) {
  if (!isFileServingAllowed(path, project.server) && !isFileServingAllowed(path, project.ctx.server)) {
    throw new Error(
      `Access denied to "${path}". See Vite config documentation for "server.fs": https://vitejs.dev/config/server-options.html#server-fs-strict.`
    );
  }
}
const readFile = async ({ project, testPath = process.cwd() }, path, options = {}) => {
  const filepath = resolve$1(dirname$1(testPath), path);
  assertFileAccess(filepath, project);
  if (typeof options === "object" && !options.encoding) {
    options.encoding = "utf-8";
  }
  return promises.readFile(filepath, options);
};
const writeFile = async ({ project, testPath = process.cwd() }, path, data, options) => {
  const filepath = resolve$1(dirname$1(testPath), path);
  assertFileAccess(filepath, project);
  const dir = dirname$1(filepath);
  if (!fs.existsSync(dir)) {
    await promises.mkdir(dir, { recursive: true });
  }
  await promises.writeFile(filepath, data, options);
};
const removeFile = async ({ project, testPath = process.cwd() }, path) => {
  const filepath = resolve$1(dirname$1(testPath), path);
  assertFileAccess(filepath, project);
  await promises.rm(filepath);
};
const _fileInfo = async ({ project, testPath = process.cwd() }, path, encoding) => {
  const filepath = resolve$1(dirname$1(testPath), path);
  assertFileAccess(filepath, project);
  const content = await promises.readFile(filepath, encoding || "base64");
  return {
    content,
    basename: basename$1(filepath),
    mime: mime.getType(filepath)
  };
};

const hover = async (context, selector, options = {}) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    await context.iframe.locator(selector).hover({
      timeout: 1e3,
      ...options
    });
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    await browser.$(selector).moveTo(options);
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support hover`);
  }
};

var clickableInputTypes;
(function(clickableInputTypes) {
    clickableInputTypes["button"] = "button";
    clickableInputTypes["color"] = "color";
    clickableInputTypes["file"] = "file";
    clickableInputTypes["image"] = "image";
    clickableInputTypes["reset"] = "reset";
    clickableInputTypes["submit"] = "submit";
    clickableInputTypes["checkbox"] = "checkbox";
    clickableInputTypes["radio"] = "radio";
})(clickableInputTypes || (clickableInputTypes = {}));

var editableInputTypes;
(function(editableInputTypes) {
    editableInputTypes["text"] = "text";
    editableInputTypes["date"] = "date";
    editableInputTypes["datetime-local"] = "datetime-local";
    editableInputTypes["email"] = "email";
    editableInputTypes["month"] = "month";
    editableInputTypes["number"] = "number";
    editableInputTypes["password"] = "password";
    editableInputTypes["search"] = "search";
    editableInputTypes["tel"] = "tel";
    editableInputTypes["time"] = "time";
    editableInputTypes["url"] = "url";
    editableInputTypes["week"] = "week";
})(editableInputTypes || (editableInputTypes = {}));

var maxLengthSupportedTypes;
(function(maxLengthSupportedTypes) {
    maxLengthSupportedTypes["email"] = "email";
    maxLengthSupportedTypes["password"] = "password";
    maxLengthSupportedTypes["search"] = "search";
    maxLengthSupportedTypes["telephone"] = "telephone";
    maxLengthSupportedTypes["text"] = "text";
    maxLengthSupportedTypes["url"] = "url";
})(maxLengthSupportedTypes || (maxLengthSupportedTypes = {}));

var bracketDict;
(function(bracketDict) {
    bracketDict["{"] = "}";
    bracketDict["["] = "]";
})(bracketDict || (bracketDict = {}));
/**
 * Read the next key definition from user input
 *
 * Describe key per `{descriptor}` or `[descriptor]`.
 * Everything else will be interpreted as a single character as descriptor - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * A previously pressed key can be released per `{/descriptor}`.
 * Keeping the key pressed can be written as `{descriptor>}`.
 * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.
 * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.
 */ function readNextDescriptor(text, context) {
    let pos = 0;
    const startBracket = text[pos] in bracketDict ? text[pos] : '';
    pos += startBracket.length;
    const isEscapedChar = new RegExp(`^\\${startBracket}{2}`).test(text);
    const type = isEscapedChar ? '' : startBracket;
    return {
        type,
        ...type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type)
    };
}
function readPrintableChar(text, pos, context) {
    const descriptor = text[pos];
    assertDescriptor(descriptor, text, pos);
    pos += descriptor.length;
    return {
        consumedLength: pos,
        descriptor,
        releasePrevious: false,
        releaseSelf: true,
        repeat: 1
    };
}
function readTag(text, pos, startBracket, context) {
    var _text_slice_match, _text_slice_match1;
    const releasePreviousModifier = text[pos] === '/' ? '/' : '';
    pos += releasePreviousModifier.length;
    const escapedDescriptor = startBracket === '{' && text[pos] === '\\';
    pos += Number(escapedDescriptor);
    const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === void 0 ? void 0 : _text_slice_match[0];
    assertDescriptor(descriptor, text, pos);
    pos += descriptor.length;
    var _text_slice_match_;
    const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === void 0 ? void 0 : _text_slice_match1[0]) !== null && _text_slice_match_ !== void 0 ? _text_slice_match_ : '';
    pos += repeatModifier.length;
    const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';
    pos += releaseSelfModifier.length;
    const expectedEndBracket = bracketDict[startBracket];
    const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';
    if (!endBracket) {
        throw new Error(getErrorMessage([
            !repeatModifier && 'repeat modifier',
            !releaseSelfModifier && 'release modifier',
            `"${expectedEndBracket}"`
        ].filter(Boolean).join(' or '), text[pos], text));
    }
    pos += endBracket.length;
    return {
        consumedLength: pos,
        descriptor,
        releasePrevious: !!releasePreviousModifier,
        repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
        releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
    };
}
function assertDescriptor(descriptor, text, pos, context) {
    if (!descriptor) {
        throw new Error(getErrorMessage('key descriptor', text[pos], text));
    }
}
function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
    if (releaseSelfModifier) {
        return releaseSelfModifier === '/';
    }
    if (repeatModifier) {
        return false;
    }
}
function getErrorMessage(expected, found, text, context) {
    return `Expected ${expected} but found "${found !== null && found !== void 0 ? found : ''}" in "${text}"
    See ${`https://testing-library.com/docs/user-event/keyboard`}
    for more information about how userEvent parses your input.`;
}

var ApiLevel;
(function(ApiLevel) {
    ApiLevel[ApiLevel["Trigger"] = 2] = "Trigger";
    ApiLevel[ApiLevel["Call"] = 1] = "Call";
})(ApiLevel || (ApiLevel = {}));

var PointerEventsCheckLevel;
(function(PointerEventsCheckLevel) {
    /**
   * Check pointer events on every user interaction that triggers a bunch of events.
   * E.g. once for releasing a mouse button even though this triggers `pointerup`, `mouseup`, `click`, etc...
   */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachTrigger"] = 4] = "EachTrigger";
    /** Check each target once per call to pointer (related) API */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachApiCall"] = 2] = "EachApiCall";
    /** Check each event target once */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachTarget"] = 1] = "EachTarget";
    /** No pointer events check */ PointerEventsCheckLevel[PointerEventsCheckLevel["Never"] = 0] = "Never";
})(PointerEventsCheckLevel || (PointerEventsCheckLevel = {}));

var DOM_KEY_LOCATION;
(function(DOM_KEY_LOCATION) {
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["STANDARD"] = 0] = "STANDARD";
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["LEFT"] = 1] = "LEFT";
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["RIGHT"] = 2] = "RIGHT";
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["NUMPAD"] = 3] = "NUMPAD";
})(DOM_KEY_LOCATION || (DOM_KEY_LOCATION = {}));

/**
 * Mapping for a default US-104-QWERTY keyboard
 */ const defaultKeyMap = [
    // alphanumeric keys
    ...'0123456789'.split('').map((c)=>({
            code: `Digit${c}`,
            key: c
        })),
    ...')!@#$%^&*('.split('').map((c, i)=>({
            code: `Digit${i}`,
            key: c,
            shiftKey: true
        })),
    ...'abcdefghijklmnopqrstuvwxyz'.split('').map((c)=>({
            code: `Key${c.toUpperCase()}`,
            key: c
        })),
    ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').map((c)=>({
            code: `Key${c}`,
            key: c,
            shiftKey: true
        })),
    // alphanumeric block - functional
    {
        code: 'Space',
        key: ' '
    },
    {
        code: 'AltLeft',
        key: 'Alt',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'AltRight',
        key: 'Alt',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'ShiftLeft',
        key: 'Shift',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'ShiftRight',
        key: 'Shift',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'ControlLeft',
        key: 'Control',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'ControlRight',
        key: 'Control',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'MetaLeft',
        key: 'Meta',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'MetaRight',
        key: 'Meta',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'OSLeft',
        key: 'OS',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'OSRight',
        key: 'OS',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'Tab',
        key: 'Tab'
    },
    {
        code: 'CapsLock',
        key: 'CapsLock'
    },
    {
        code: 'Backspace',
        key: 'Backspace'
    },
    {
        code: 'Enter',
        key: 'Enter'
    },
    // function
    {
        code: 'Escape',
        key: 'Escape'
    },
    // arrows
    {
        code: 'ArrowUp',
        key: 'ArrowUp'
    },
    {
        code: 'ArrowDown',
        key: 'ArrowDown'
    },
    {
        code: 'ArrowLeft',
        key: 'ArrowLeft'
    },
    {
        code: 'ArrowRight',
        key: 'ArrowRight'
    },
    // control pad
    {
        code: 'Home',
        key: 'Home'
    },
    {
        code: 'End',
        key: 'End'
    },
    {
        code: 'Delete',
        key: 'Delete'
    },
    {
        code: 'PageUp',
        key: 'PageUp'
    },
    {
        code: 'PageDown',
        key: 'PageDown'
    },
    // Special keys that are not part of a default US-layout but included for specific behavior
    {
        code: 'Fn',
        key: 'Fn'
    },
    {
        code: 'Symbol',
        key: 'Symbol'
    },
    {
        code: 'AltRight',
        key: 'AltGraph'
    }
];

/**
 * Parse key defintions per `keyboardMap`
 *
 * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.
 * Everything else will be interpreted as a typed character - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * Keeping the key pressed can be written as `{key>}`.
 * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.
 * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.
 */ function parseKeyDef(keyboardMap, text) {
    const defs = [];
    do {
        const { type, descriptor, consumedLength, releasePrevious, releaseSelf = true, repeat } = readNextDescriptor(text);
        var _keyboardMap_find;
        const keyDef = (_keyboardMap_find = keyboardMap.find((def)=>{
            if (type === '[') {
                var _def_code;
                return ((_def_code = def.code) === null || _def_code === void 0 ? void 0 : _def_code.toLowerCase()) === descriptor.toLowerCase();
            } else if (type === '{') {
                var _def_key;
                return ((_def_key = def.key) === null || _def_key === void 0 ? void 0 : _def_key.toLowerCase()) === descriptor.toLowerCase();
            }
            return def.key === descriptor;
        })) !== null && _keyboardMap_find !== void 0 ? _keyboardMap_find : {
            key: 'Unknown',
            code: 'Unknown',
            [type === '[' ? 'code' : 'key']: descriptor
        };
        defs.push({
            keyDef,
            releasePrevious,
            releaseSelf,
            repeat
        });
        text = text.slice(consumedLength);
    }while (text)
    return defs;
}

const keyboard = async (context, text, state) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const frame = await context.frame();
    await frame.evaluate(focusIframe);
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    await context.browser.execute(focusIframe);
  }
  const pressed = new Set(state.unreleased);
  await keyboardImplementation(
    pressed,
    context.provider,
    context.contextId,
    text,
    async () => {
      if (context.provider instanceof PlaywrightBrowserProvider) {
        const frame = await context.frame();
        await frame.evaluate(selectAll);
      } else if (context.provider instanceof WebdriverBrowserProvider) {
        await context.browser.execute(selectAll);
      } else {
        throw new TypeError(`Provider "${context.provider.name}" does not support selecting all text`);
      }
    },
    true
  );
  return {
    unreleased: Array.from(pressed)
  };
};
const keyboardCleanup = async (context, state) => {
  const { provider, contextId } = context;
  if (provider instanceof PlaywrightBrowserProvider) {
    const page = provider.getPage(contextId);
    for (const key of state.unreleased) {
      await page.keyboard.up(key);
    }
  } else if (provider instanceof WebdriverBrowserProvider) {
    const keyboard2 = provider.browser.action("key");
    for (const key of state.unreleased) {
      keyboard2.up(key);
    }
    await keyboard2.perform();
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support keyboard api`);
  }
};
const VALID_KEYS = /* @__PURE__ */ new Set(["Escape", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "Backquote", "`", "~", "Digit1", "1", "!", "Digit2", "2", "@", "Digit3", "3", "#", "Digit4", "4", "$", "Digit5", "5", "%", "Digit6", "6", "^", "Digit7", "7", "&", "Digit8", "8", "*", "Digit9", "9", "(", "Digit0", "0", ")", "Minus", "-", "_", "Equal", "=", "+", "Backslash", "\\", "|", "Backspace", "Tab", "KeyQ", "q", "Q", "KeyW", "w", "W", "KeyE", "e", "E", "KeyR", "r", "R", "KeyT", "t", "T", "KeyY", "y", "Y", "KeyU", "u", "U", "KeyI", "i", "I", "KeyO", "o", "O", "KeyP", "p", "P", "BracketLeft", "[", "{", "BracketRight", "]", "}", "CapsLock", "KeyA", "a", "A", "KeyS", "s", "S", "KeyD", "d", "D", "KeyF", "f", "F", "KeyG", "g", "G", "KeyH", "h", "H", "KeyJ", "j", "J", "KeyK", "k", "K", "KeyL", "l", "L", "Semicolon", ";", ":", "Quote", "'", '"', "Enter", "\n", "\r", "ShiftLeft", "Shift", "KeyZ", "z", "Z", "KeyX", "x", "X", "KeyC", "c", "C", "KeyV", "v", "V", "KeyB", "b", "B", "KeyN", "n", "N", "KeyM", "m", "M", "Comma", ",", "<", "Period", ".", ">", "Slash", "/", "?", "ShiftRight", "ControlLeft", "Control", "MetaLeft", "Meta", "AltLeft", "Alt", "Space", " ", "AltRight", "AltGraph", "MetaRight", "ContextMenu", "ControlRight", "PrintScreen", "ScrollLock", "Pause", "PageUp", "PageDown", "Insert", "Delete", "Home", "End", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "NumLock", "NumpadDivide", "NumpadMultiply", "NumpadSubtract", "Numpad7", "Numpad8", "Numpad9", "Numpad4", "Numpad5", "Numpad6", "NumpadAdd", "Numpad1", "Numpad2", "Numpad3", "Numpad0", "NumpadDecimal", "NumpadEnter"]);
async function keyboardImplementation(pressed, provider, contextId, text, selectAll2, skipRelease) {
  if (provider instanceof PlaywrightBrowserProvider) {
    const page = provider.getPage(contextId);
    const actions = parseKeyDef(defaultKeyMap, text);
    for (const { releasePrevious, releaseSelf, repeat, keyDef } of actions) {
      const key = keyDef.key;
      if (pressed.has(key)) {
        if (VALID_KEYS.has(key)) {
          await page.keyboard.up(key);
        }
        pressed.delete(key);
      }
      if (!releasePrevious) {
        if (key === "selectall") {
          await selectAll2();
          continue;
        }
        for (let i = 1; i <= repeat; i++) {
          if (VALID_KEYS.has(key)) {
            await page.keyboard.down(key);
          } else {
            await page.keyboard.insertText(key);
          }
        }
        if (releaseSelf) {
          if (VALID_KEYS.has(key)) {
            await page.keyboard.up(key);
          }
        } else {
          pressed.add(key);
        }
      }
    }
    if (!skipRelease && pressed.size) {
      for (const key of pressed) {
        if (VALID_KEYS.has(key)) {
          await page.keyboard.up(key);
        }
      }
    }
  } else if (provider instanceof WebdriverBrowserProvider) {
    const { Key } = await import('webdriverio');
    const browser = provider.browser;
    const actions = parseKeyDef(defaultKeyMap, text);
    let keyboard2 = browser.action("key");
    for (const { releasePrevious, releaseSelf, repeat, keyDef } of actions) {
      let key = keyDef.key;
      const code = "location" in keyDef ? keyDef.key : keyDef.code;
      const special = Key[code];
      if (special) {
        key = special;
      }
      if (pressed.has(key)) {
        keyboard2.up(key);
        pressed.delete(key);
      }
      if (!releasePrevious) {
        if (key === "selectall") {
          await keyboard2.perform();
          keyboard2 = browser.action("key");
          await selectAll2();
          continue;
        }
        for (let i = 1; i <= repeat; i++) {
          keyboard2.down(key);
        }
        if (releaseSelf) {
          keyboard2.up(key);
        } else {
          pressed.add(key);
        }
      }
    }
    const allRelease = keyboard2.toJSON().actions.every((action) => action.type === "keyUp");
    await keyboard2.perform(allRelease ? false : skipRelease);
  }
  return {
    pressed
  };
}
function focusIframe() {
  if (!document.activeElement || document.activeElement.ownerDocument !== document || document.activeElement === document.body) {
    window.focus();
  }
}
function selectAll() {
  const element = document.activeElement;
  if (element && element.select) {
    element.select();
  }
}

const screenshot = async (context, name, options = {}) => {
  if (!context.testPath) {
    throw new Error(`Cannot take a screenshot without a test path`);
  }
  const path = options.path ? resolve(dirname(context.testPath), options.path) : resolveScreenshotPath(
    context.testPath,
    name,
    context.project.config
  );
  const savePath = normalize$1(path);
  await mkdir(dirname(path), { recursive: true });
  if (context.provider instanceof PlaywrightBrowserProvider) {
    if (options.element) {
      const { element: selector, ...config } = options;
      const element = context.iframe.locator(`${selector}`);
      const buffer2 = await element.screenshot({
        timeout: 1e3,
        ...config,
        path: savePath
      });
      return returnResult(options, path, buffer2);
    }
    const buffer = await context.iframe.locator("body").screenshot({
      ...options,
      path: savePath
    });
    return returnResult(options, path, buffer);
  }
  if (context.provider instanceof WebdriverBrowserProvider) {
    const page = context.provider.browser;
    if (!options.element) {
      const body = await page.$("body");
      const buffer2 = await body.saveScreenshot(savePath);
      return returnResult(options, path, buffer2);
    }
    const element = await page.$(`${options.element}`);
    const buffer = await element.saveScreenshot(savePath);
    return returnResult(options, path, buffer);
  }
  throw new Error(
    `Provider "${context.provider.name}" does not support screenshots`
  );
};
function resolveScreenshotPath(testPath, name, config) {
  const dir = dirname(testPath);
  const base = basename(testPath);
  if (config.browser.screenshotDirectory) {
    return resolve(
      config.browser.screenshotDirectory,
      relative(config.root, dir),
      base,
      name
    );
  }
  return resolve(dir, "__screenshots__", base, name);
}
function returnResult(options, path, buffer) {
  if (options.base64) {
    return { path, base64: buffer.toString("base64") };
  }
  return path;
}

const selectOptions = async (context, selector, userValues, options = {}) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const value = userValues;
    const { iframe } = context;
    const selectElement = iframe.locator(selector);
    const values = await Promise.all(value.map(async (v) => {
      if (typeof v === "string") {
        return v;
      }
      const elementHandler = await iframe.locator(v.element).elementHandle();
      if (!elementHandler) {
        throw new Error(`Element not found: ${v.element}`);
      }
      return elementHandler;
    }));
    await selectElement.selectOption(values, {
      timeout: 1e3,
      ...options
    });
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const values = userValues;
    if (!values.length) {
      return;
    }
    const browser = context.browser;
    if (values.length === 1 && "index" in values[0]) {
      const selectElement = browser.$(selector);
      await selectElement.selectByIndex(values[0].index);
    } else {
      throw new Error(`Provider "webdriverio" doesn't support selecting multiple values at once`);
    }
  } else {
    throw new TypeError(`Provider "${context.provider.name}" doesn't support selectOptions command`);
  }
};

const tab = async (context, options = {}) => {
  const provider = context.provider;
  if (provider instanceof PlaywrightBrowserProvider) {
    const page = context.page;
    await page.keyboard.press(options.shift === true ? "Shift+Tab" : "Tab");
    return;
  }
  if (provider instanceof WebdriverBrowserProvider) {
    const { Key } = await import('webdriverio');
    const browser = context.browser;
    await browser.keys(options.shift === true ? [Key.Shift, Key.Tab] : [Key.Tab]);
    return;
  }
  throw new Error(`Provider "${provider.name}" doesn't support tab command`);
};

const type = async (context, selector, text, options = {}) => {
  const { skipClick = false, skipAutoClose = false } = options;
  const unreleased = new Set(Reflect.get(options, "unreleased") ?? []);
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const { iframe } = context;
    const element = iframe.locator(selector);
    if (!skipClick) {
      await element.focus();
    }
    await keyboardImplementation(
      unreleased,
      context.provider,
      context.contextId,
      text,
      () => element.selectText(),
      skipAutoClose
    );
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    const element = browser.$(selector);
    if (!skipClick && !await element.isFocused()) {
      await element.click();
    }
    await keyboardImplementation(
      unreleased,
      context.provider,
      context.contextId,
      text,
      () => browser.execute(() => {
        const element2 = document.activeElement;
        if (element2) {
          element2.select();
        }
      }),
      skipAutoClose
    );
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support typing`);
  }
  return {
    unreleased: Array.from(unreleased)
  };
};

const upload = async (context, selector, files) => {
  const testPath = context.testPath;
  if (!testPath) {
    throw new Error(`Cannot upload files outside of a test`);
  }
  const testDir = dirname(testPath);
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const { iframe } = context;
    const playwrightFiles = files.map((file) => {
      if (typeof file === "string") {
        return resolve(testDir, file);
      }
      return {
        name: file.name,
        mimeType: file.mimeType,
        buffer: Buffer.from(file.base64, "base64")
      };
    });
    await iframe.locator(selector).setInputFiles(playwrightFiles);
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    for (const file of files) {
      if (typeof file !== "string") {
        throw new TypeError(`The "${context.provider.name}" provider doesn't support uploading files objects. Provide a file path instead.`);
      }
    }
    const element = context.browser.$(selector);
    for (const file of files) {
      const filepath = resolve(testDir, file);
      const remoteFilePath = await context.browser.uploadFile(filepath);
      await element.addValue(remoteFilePath);
    }
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support uploading files via userEvent.upload`);
  }
};

var builtinCommands = {
  readFile,
  removeFile,
  writeFile,
  __vitest_fileInfo: _fileInfo,
  __vitest_upload: upload,
  __vitest_click: click,
  __vitest_dblClick: dblClick,
  __vitest_tripleClick: tripleClick,
  __vitest_screenshot: screenshot,
  __vitest_type: type,
  __vitest_clear: clear,
  __vitest_fill: fill,
  __vitest_tab: tab,
  __vitest_keyboard: keyboard,
  __vitest_selectOptions: selectOptions,
  __vitest_dragAndDrop: dragAndDrop,
  __vitest_hover: hover,
  __vitest_cleanup: keyboardCleanup
};

const VIRTUAL_ID_CONTEXT = "\0@vitest/browser/context";
const ID_CONTEXT = "@vitest/browser/context";
const __dirname = dirname(fileURLToPath(import.meta.url));
function BrowserContext(server) {
  const project = server.project;
  project.config.browser.commands ??= {};
  for (const [name, command] of Object.entries(builtinCommands)) {
    project.config.browser.commands[name] ??= command;
  }
  for (const command in project.config.browser.commands) {
    if (!/^[a-z_$][\w$]*$/i.test(command)) {
      throw new Error(
        `Invalid command name "${command}". Only alphanumeric characters, $ and _ are allowed.`
      );
    }
  }
  return {
    name: "vitest:browser:virtual-module:context",
    enforce: "pre",
    resolveId(id) {
      if (id === ID_CONTEXT) {
        return VIRTUAL_ID_CONTEXT;
      }
    },
    load(id) {
      if (id === VIRTUAL_ID_CONTEXT) {
        return generateContextFile.call(this, server);
      }
    }
  };
}
async function generateContextFile(server) {
  const commands = Object.keys(server.project.config.browser.commands ?? {});
  const filepathCode = "__vitest_worker__.filepath || __vitest_worker__.current?.file?.filepath || undefined";
  const provider = server.provider;
  const commandsCode = commands.filter((command) => !command.startsWith("__vitest")).map((command) => {
    return `    ["${command}"]: (...args) => rpc().triggerCommand(contextId, "${command}", filepath(), args),`;
  }).join("\n");
  const userEventNonProviderImport = await getUserEventImport(
    provider,
    this.resolve.bind(this)
  );
  const distContextPath = slash(`/@fs/${resolve(__dirname, "context.js")}`);
  return `
import { page, createUserEvent, cdp } from '${distContextPath}'
${userEventNonProviderImport}
const filepath = () => ${filepathCode}
const rpc = () => __vitest_worker__.rpc
const contextId = __vitest_browser_runner__.contextId

export const server = {
  platform: ${JSON.stringify(process.platform)},
  version: ${JSON.stringify(process.version)},
  provider: ${JSON.stringify(provider.name)},
  browser: ${JSON.stringify(server.project.config.browser.name)},
  commands: {
    ${commandsCode}
  },
  config: __vitest_browser_runner__.config,
}
export const commands = server.commands
export const userEvent = createUserEvent(_userEventSetup)
export { page, cdp }
`;
}
async function getUserEventImport(provider, resolve2) {
  if (provider.name !== "preview") {
    return "const _userEventSetup = undefined";
  }
  const resolved = await resolve2("@testing-library/user-event", __dirname);
  if (!resolved) {
    throw new Error(`Failed to resolve user-event package from ${__dirname}`);
  }
  return `import { userEvent as __vitest_user_event__ } from '${slash(`/@fs/${resolved.id}`)}'
const _userEventSetup = __vitest_user_event__
`;
}

function replacer(code, values) {
  return code.replace(/\{\s*(\w+)\s*\}/g, (_, key) => values[key] ?? _);
}
const builtinProviders = ["webdriverio", "playwright", "preview"];
async function getBrowserProvider(options, project) {
  if (options.provider == null || builtinProviders.includes(options.provider)) {
    const providers = await import('./providers.js');
    const provider = options.provider || "preview";
    return providers[provider];
  }
  let customProviderModule;
  try {
    customProviderModule = await project.runner.executeId(
      options.provider
    );
  } catch (error) {
    throw new Error(
      `Failed to load custom BrowserProvider from ${options.provider}`,
      { cause: error }
    );
  }
  if (customProviderModule.default == null) {
    throw new Error(
      `Custom BrowserProvider loaded from ${options.provider} was not the default export`
    );
  }
  return customProviderModule.default;
}

async function resolveOrchestrator(server, url, res) {
  const project = server.project;
  let contextId = url.searchParams.get("contextId");
  if (!contextId) {
    const contexts = [...server.state.orchestrators.keys()];
    contextId = contexts[contexts.length - 1] ?? "none";
  }
  const files = server.state.getContext(contextId)?.files ?? [];
  const injectorJs = typeof server.injectorJs === "string" ? server.injectorJs : await server.injectorJs;
  const injector = replacer(injectorJs, {
    __VITEST_PROVIDER__: JSON.stringify(server.provider.name),
    __VITEST_CONFIG__: JSON.stringify(server.getSerializableConfig()),
    __VITEST_VITE_CONFIG__: JSON.stringify({
      root: server.vite.config.root
    }),
    __VITEST_FILES__: JSON.stringify(files),
    __VITEST_TYPE__: '"orchestrator"',
    __VITEST_CONTEXT_ID__: JSON.stringify(contextId),
    __VITEST_TESTER_ID__: '"none"',
    __VITEST_PROVIDED_CONTEXT__: "{}",
    __VITEST_API_TOKEN__: JSON.stringify(project.ctx.config.api.token)
  });
  res.removeHeader("Content-Security-Policy");
  if (!server.orchestratorScripts) {
    server.orchestratorScripts = (await server.formatScripts(
      project.config.browser.orchestratorScripts
    )).map((script) => {
      let html = "<script ";
      for (const attr in script.attrs || {}) {
        html += `${attr}="${script.attrs[attr]}" `;
      }
      html += `>${script.children}<\/script>`;
      return html;
    }).join("\n");
  }
  let baseHtml = typeof server.orchestratorHtml === "string" ? server.orchestratorHtml : await server.orchestratorHtml;
  if (project.config.browser.ui) {
    const manifestContent = server.manifest instanceof Promise ? await server.manifest : server.manifest;
    const jsEntry = manifestContent["orchestrator.html"].file;
    const base = server.vite.config.base || "/";
    baseHtml = baseHtml.replaceAll("./assets/", `${base}__vitest__/assets/`).replace(
      "<!-- !LOAD_METADATA! -->",
      [
        "{__VITEST_INJECTOR__}",
        "{__VITEST_ERROR_CATCHER__}",
        "{__VITEST_SCRIPTS__}",
        `<script type="module" crossorigin src="${base}${jsEntry}"><\/script>`
      ].join("\n")
    );
  }
  return replacer(baseHtml, {
    __VITEST_FAVICON__: server.faviconUrl,
    __VITEST_TITLE__: "Vitest Browser Runner",
    __VITEST_SCRIPTS__: server.orchestratorScripts,
    __VITEST_INJECTOR__: `<script type="module">${injector}<\/script>`,
    __VITEST_ERROR_CATCHER__: `<script type="module" src="${server.errorCatcherUrl}"><\/script>`,
    __VITEST_CONTEXT_ID__: JSON.stringify(contextId)
  });
}

/// <reference types="../types/index.d.ts" />

// (c) 2020-present Andrea Giammarchi

const {parse: $parse, stringify: $stringify} = JSON;
const {keys} = Object;

const Primitive = String;   // it could be Number
const primitive = 'string'; // it could be 'number'

const ignore = {};
const object = 'object';

const noop = (_, value) => value;

const primitives = value => (
  value instanceof Primitive ? Primitive(value) : value
);

const Primitives = (_, value) => (
  typeof value === primitive ? new Primitive(value) : value
);

const revive = (input, parsed, output, $) => {
  const lazy = [];
  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {
    const k = ke[y];
    const value = output[k];
    if (value instanceof Primitive) {
      const tmp = input[value];
      if (typeof tmp === object && !parsed.has(tmp)) {
        parsed.add(tmp);
        output[k] = ignore;
        lazy.push({k, a: [input, parsed, tmp, $]});
      }
      else
        output[k] = $.call(output, k, tmp);
    }
    else if (output[k] !== ignore)
      output[k] = $.call(output, k, value);
  }
  for (let {length} = lazy, i = 0; i < length; i++) {
    const {k, a} = lazy[i];
    output[k] = $.call(output, k, revive.apply(null, a));
  }
  return output;
};

const set = (known, input, value) => {
  const index = Primitive(input.push(value) - 1);
  known.set(value, index);
  return index;
};

/**
 * Converts a specialized flatted string into a JS value.
 * @param {string} text
 * @param {(this: any, key: string, value: any) => any} [reviver]
 * @returns {any}
 */
const parse = (text, reviver) => {
  const input = $parse(text, Primitives).map(primitives);
  const value = input[0];
  const $ = reviver || noop;
  const tmp = typeof value === object && value ?
              revive(input, new Set, value, $) :
              value;
  return $.call({'': tmp}, '', tmp);
};

/**
 * Converts a JS value into a specialized flatted string.
 * @param {any} value
 * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]
 * @param {string | number | undefined} [space]
 * @returns {string}
 */
const stringify = (value, replacer, space) => {
  const $ = replacer && typeof replacer === object ?
            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :
            (replacer || noop);
  const known = new Map;
  const input = [];
  const output = [];
  let i = +set(known, input, $.call({'': value}, '', value));
  let firstRun = !i;
  while (i < input.length) {
    firstRun = true;
    output[i] = $stringify(input[i++], replace, space);
  }
  return '[' + output.join(',') + ']';
  function replace(key, value) {
    if (firstRun) {
      firstRun = !firstRun;
      return value;
    }
    const after = $.call(this, key, value);
    switch (typeof after) {
      case object:
        if (after === null) return after;
      case primitive:
        return known.get(after) || set(known, input, after);
    }
    return after;
  }
};

async function resolveTester(server, url, res, next) {
  const csp = res.getHeader("Content-Security-Policy");
  if (typeof csp === "string") {
    res.setHeader(
      "Content-Security-Policy",
      csp.replace(/frame-ancestors [^;]+/, "frame-ancestors *")
    );
  }
  const { contextId, testFile } = server.resolveTesterUrl(url.pathname);
  const project = server.project;
  const state = server.state;
  const { testFiles } = await project.globTestFiles();
  const tests = testFile === "__vitest_all__" || !testFiles.includes(testFile) ? "__vitest_browser_runner__.files" : JSON.stringify([testFile]);
  const iframeId = JSON.stringify(testFile);
  const context = state.getContext(contextId);
  const files = context?.files ?? [];
  const method = context?.method ?? "run";
  const injectorJs = typeof server.injectorJs === "string" ? server.injectorJs : await server.injectorJs;
  const injector = replacer(injectorJs, {
    __VITEST_PROVIDER__: JSON.stringify(server.provider.name),
    __VITEST_CONFIG__: JSON.stringify(server.getSerializableConfig()),
    __VITEST_FILES__: JSON.stringify(files),
    __VITEST_VITE_CONFIG__: JSON.stringify({
      root: server.vite.config.root
    }),
    __VITEST_TYPE__: '"tester"',
    __VITEST_CONTEXT_ID__: JSON.stringify(contextId),
    __VITEST_TESTER_ID__: JSON.stringify(crypto.randomUUID()),
    __VITEST_PROVIDED_CONTEXT__: JSON.stringify(stringify(project.getProvidedContext())),
    __VITEST_API_TOKEN__: JSON.stringify(project.ctx.config.api.token)
  });
  const testerHtml = typeof server.testerHtml === "string" ? server.testerHtml : await server.testerHtml;
  try {
    const url2 = join("/@fs/", server.testerFilepath);
    const indexhtml = await server.vite.transformIndexHtml(url2, testerHtml);
    return replacer(indexhtml, {
      __VITEST_FAVICON__: server.faviconUrl,
      __VITEST_INJECTOR__: injector,
      __VITEST_APPEND__: `
    __vitest_browser_runner__.runningFiles = ${tests}
    __vitest_browser_runner__.iframeId = ${iframeId}
    __vitest_browser_runner__.${method === "run" ? "runTests" : "collectTests"}(__vitest_browser_runner__.runningFiles)
    document.querySelector('script[data-vitest-append]').remove()
    `
    });
  } catch (err) {
    context?.reject(err);
    next(err);
  }
}

const versionRegexp = /(?:\?|&)v=\w{8}/;
var BrowserPlugin = (browserServer, base = "/") => {
  const project = browserServer.project;
  function isPackageExists(pkg, root) {
    return browserServer.project.ctx.packageInstaller.isPackageExists?.(pkg, {
      paths: [root]
    });
  }
  return [
    {
      enforce: "pre",
      name: "vitest:browser",
      async configureServer(server) {
        browserServer.setServer(server);
        server.middlewares.use(function vitestHeaders(_req, res, next) {
          const headers = server.config.server.headers;
          if (headers) {
            for (const name in headers) {
              res.setHeader(name, headers[name]);
            }
          }
          next();
        });
        server.middlewares.use(async function vitestBrowserMode(req, res, next) {
          if (!req.url || !browserServer.provider) {
            return next();
          }
          const url = new URL(req.url, "http://localhost");
          if (!url.pathname.startsWith(browserServer.prefixTesterUrl) && url.pathname !== base) {
            return next();
          }
          res.setHeader(
            "Cache-Control",
            "no-cache, max-age=0, must-revalidate"
          );
          res.setHeader("Content-Type", "text/html; charset=utf-8");
          res.removeHeader("X-Frame-Options");
          if (url.pathname === base) {
            const html2 = await resolveOrchestrator(browserServer, url, res);
            res.write(html2, "utf-8");
            res.end();
            return;
          }
          const html = await resolveTester(browserServer, url, res, next);
          if (html) {
            res.write(html, "utf-8");
            res.end();
          }
        });
        server.middlewares.use(
          `${base}favicon.svg`,
          (_, res) => {
            const content = readFileSync(resolve(distRoot, "client/favicon.svg"));
            res.write(content, "utf-8");
            res.end();
          }
        );
        const coverageFolder = resolveCoverageFolder(project);
        const coveragePath = coverageFolder ? coverageFolder[1] : void 0;
        if (coveragePath && base === coveragePath) {
          throw new Error(
            `The ui base path and the coverage path cannot be the same: ${base}, change coverage.reportsDirectory`
          );
        }
        if (coverageFolder) {
          server.middlewares.use(
            coveragePath,
            sirv(coverageFolder[0], {
              single: true,
              dev: true,
              setHeaders: (res) => {
                res.setHeader(
                  "Cache-Control",
                  "public,max-age=0,must-revalidate"
                );
              }
            })
          );
        }
        const screenshotFailures = project.config.browser.ui && project.config.browser.screenshotFailures;
        if (screenshotFailures) {
          server.middlewares.use(`${base}__screenshot-error`, function vitestBrowserScreenshotError(req, res) {
            if (!req.url || !browserServer.provider) {
              res.statusCode = 404;
              res.end();
              return;
            }
            const url = new URL(req.url, "http://localhost");
            const id = url.searchParams.get("id");
            if (!id) {
              res.statusCode = 404;
              res.end();
              return;
            }
            const task = project.ctx.state.idMap.get(id);
            const file = task?.meta.failScreenshotPath;
            if (!file) {
              res.statusCode = 404;
              res.end();
              return;
            }
            let stat;
            try {
              stat = lstatSync(file);
            } catch {
            }
            if (!stat?.isFile()) {
              res.statusCode = 404;
              res.end();
              return;
            }
            const ext = extname(file);
            const buffer = readFileSync(file);
            res.setHeader(
              "Cache-Control",
              "public,max-age=0,must-revalidate"
            );
            res.setHeader("Content-Length", buffer.length);
            res.setHeader("Content-Type", ext === "jpeg" || ext === "jpg" ? "image/jpeg" : ext === "webp" ? "image/webp" : "image/png");
            res.end(buffer);
          });
        }
        server.middlewares.use((req, res, next) => {
          if (req.url && versionRegexp.test(req.url) && !req.url.includes("chunk-")) {
            res.setHeader("Cache-Control", "no-cache");
            const setHeader = res.setHeader.bind(res);
            res.setHeader = function(name, value) {
              if (name === "Cache-Control") {
                return res;
              }
              return setHeader(name, value);
            };
          }
          next();
        });
      }
    },
    {
      name: "vitest:browser:tests",
      enforce: "pre",
      async config() {
        const { testFiles: allTestFiles } = await project.globTestFiles();
        const browserTestFiles = allTestFiles.filter(
          (file) => getFilePoolName(project, file) === "browser"
        );
        const setupFiles = toArray(project.config.setupFiles);
        const define = {};
        for (const env in project.config.env || {}) {
          const stringValue = JSON.stringify(project.config.env[env]);
          define[`import.meta.env.${env}`] = stringValue;
        }
        const entries = [
          ...browserTestFiles,
          ...setupFiles,
          resolve(distDir, "index.js"),
          resolve(distDir, "browser.js"),
          resolve(distDir, "runners.js"),
          resolve(distDir, "utils.js"),
          ...project.config.snapshotSerializers || []
        ];
        const exclude = [
          "vitest",
          "vitest/utils",
          "vitest/browser",
          "vitest/runners",
          "@vitest/browser",
          "@vitest/browser/client",
          "@vitest/utils",
          "@vitest/utils/source-map",
          "@vitest/runner",
          "@vitest/spy",
          "@vitest/utils/error",
          "@vitest/snapshot",
          "@vitest/expect",
          "std-env",
          "tinybench",
          "tinyspy",
          "tinyrainbow",
          "pathe",
          "msw",
          "msw/browser"
        ];
        if (project.config.diff) {
          entries.push(project.config.diff);
        }
        if (project.ctx.coverageProvider) {
          const coverage = project.ctx.config.coverage;
          const provider = coverage.provider;
          if (provider === "v8") {
            const path = tryResolve("@vitest/coverage-v8", [project.config.root]);
            if (path) {
              entries.push(path);
              exclude.push("@vitest/coverage-v8/browser");
            }
          } else if (provider === "istanbul") {
            const path = tryResolve("@vitest/coverage-istanbul", [project.config.root]);
            if (path) {
              entries.push(path);
              exclude.push("@vitest/coverage-istanbul");
            }
          } else if (provider === "custom" && coverage.customProviderModule) {
            entries.push(coverage.customProviderModule);
          }
        }
        const include = [
          "vitest > expect-type",
          "vitest > @vitest/snapshot > magic-string",
          "vitest > chai",
          "vitest > chai > loupe",
          "vitest > @vitest/utils > loupe",
          "@vitest/browser > @testing-library/user-event",
          "@vitest/browser > @testing-library/dom"
        ];
        const fileRoot = browserTestFiles[0] ? dirname(browserTestFiles[0]) : project.config.root;
        const svelte = isPackageExists("vitest-browser-svelte", fileRoot);
        if (svelte) {
          exclude.push("vitest-browser-svelte");
        }
        const vueTestUtils = isPackageExists("@vue/test-utils", fileRoot);
        if (vueTestUtils) {
          include.push("@vue/test-utils");
        }
        return {
          define,
          resolve: {
            dedupe: ["vitest"]
          },
          optimizeDeps: {
            entries,
            exclude,
            include
          }
        };
      },
      async resolveId(id) {
        if (!/\?browserv=\w+$/.test(id)) {
          return;
        }
        let useId = id.slice(0, id.lastIndexOf("?"));
        if (useId.startsWith("/@fs/")) {
          useId = useId.slice(5);
        }
        if (/^\w:/.test(useId)) {
          useId = useId.replace(/\\/g, "/");
        }
        return useId;
      }
    },
    {
      name: "vitest:browser:resolve-virtual",
      async resolveId(rawId) {
        if (rawId === "/mockServiceWorker.js") {
          return this.resolve("msw/mockServiceWorker.js", distRoot, {
            skipSelf: true
          });
        }
      }
    },
    {
      name: "vitest:browser:assets",
      configureServer(server) {
        server.middlewares.use(
          "/__vitest__",
          sirv(resolve(distRoot, "client/__vitest__"))
        );
      },
      resolveId(id) {
        if (id.startsWith("/__vitest_browser__/")) {
          return resolve(distRoot, "client", id.slice(1));
        }
      },
      transform(code, id) {
        if (id.includes(browserServer.vite.config.cacheDir) && id.includes("loupe.js")) {
          const utilRequire = "nodeUtil = require_util();";
          return code.replace(utilRequire, " ".repeat(utilRequire.length));
        }
      }
    },
    BrowserContext(browserServer),
    dynamicImportPlugin({
      globalThisAccessor: '"__vitest_browser_runner__"',
      filter(id) {
        if (id.includes(distRoot)) {
          return false;
        }
        return true;
      }
    }),
    {
      name: "vitest:browser:config",
      enforce: "post",
      async config(viteConfig) {
        // Enables using ignore hint for coverage providers with @preserve keyword
        if (viteConfig.esbuild !== false) {
          viteConfig.esbuild ||= {};
          viteConfig.esbuild.legalComments = "inline";
        }
        const defaultPort = project.ctx._browserLastPort++;
        const api = resolveApiServerConfig(
          viteConfig.test?.browser || {},
          defaultPort
        );
        viteConfig.server = {
          ...viteConfig.server,
          port: defaultPort,
          ...api,
          middlewareMode: false,
          open: false
        };
        viteConfig.server.fs ??= {};
        viteConfig.server.fs.allow = viteConfig.server.fs.allow || [];
        viteConfig.server.fs.allow.push(
          ...resolveFsAllow(
            project.ctx.config.root,
            project.ctx.server.config.configFile
          ),
          distRoot
        );
        return {
          resolve: {
            alias: viteConfig.test?.alias
          }
        };
      }
    },
    {
      name: "vitest:browser:in-source-tests",
      transform(code, id) {
        if (!project.isTestFile(id) || !code.includes("import.meta.vitest")) {
          return;
        }
        const s = new MagicString(code, { filename: cleanUrl(id) });
        s.prepend(
          `import.meta.vitest = __vitest_index__;
`
        );
        return {
          code: s.toString(),
          map: s.generateMap({ hires: true })
        };
      }
    },
    {
      name: "vitest:browser:worker",
      transform(code, id, _options) {
        if (/(?:\?|&)worker_file&type=\w+(?:&|$)/.test(id)) {
          const s = new MagicString(code);
          s.prepend("globalThis.__vitest_browser_runner__ = { wrapDynamicImport: f => f() };\n");
          return {
            code: s.toString(),
            map: s.generateMap({ hires: "boundary" })
          };
        }
      }
    },
    {
      name: "vitest:browser:transform-tester-html",
      enforce: "pre",
      async transformIndexHtml(html, ctx) {
        if (ctx.filename !== browserServer.testerFilepath) {
          return;
        }
        if (!browserServer.testerScripts) {
          const testerScripts = await browserServer.formatScripts(
            project.config.browser.testerScripts
          );
          browserServer.testerScripts = testerScripts;
        }
        const stateJs = typeof browserServer.stateJs === "string" ? browserServer.stateJs : await browserServer.stateJs;
        const testerTags = [];
        const isDefaultTemplate = resolve(distRoot, "client/tester/tester.html") === browserServer.testerFilepath;
        if (!isDefaultTemplate) {
          const manifestContent = browserServer.manifest instanceof Promise ? await browserServer.manifest : browserServer.manifest;
          const testerEntry = manifestContent["tester/tester.html"];
          testerTags.push({
            tag: "script",
            attrs: {
              type: "module",
              crossorigin: "",
              src: `${browserServer.base}${testerEntry.file}`
            },
            injectTo: "head"
          });
          for (const importName of testerEntry.imports || []) {
            const entryManifest = manifestContent[importName];
            if (entryManifest) {
              testerTags.push(
                {
                  tag: "link",
                  attrs: {
                    href: `${browserServer.base}${entryManifest.file}`,
                    rel: "modulepreload",
                    crossorigin: ""
                  },
                  injectTo: "head"
                }
              );
            }
          }
        } else {
          testerTags.push({
            tag: "style",
            children: `
html {
  padding: 0;
  margin: 0;
}
body {
  padding: 0;
  margin: 0;
  min-height: 100vh;
}`,
            injectTo: "head"
          });
        }
        return [
          {
            tag: "script",
            children: "{__VITEST_INJECTOR__}",
            injectTo: "head-prepend"
          },
          {
            tag: "script",
            children: stateJs,
            injectTo: "head-prepend"
          },
          {
            tag: "script",
            attrs: {
              type: "module",
              src: browserServer.errorCatcherUrl
            },
            injectTo: "head"
          },
          browserServer.locatorsUrl ? {
            tag: "script",
            attrs: {
              type: "module",
              src: browserServer.locatorsUrl
            },
            injectTo: "head"
          } : null,
          ...browserServer.testerScripts,
          ...testerTags,
          {
            tag: "script",
            attrs: {
              "type": "module",
              "data-vitest-append": ""
            },
            children: "{__VITEST_APPEND__}",
            injectTo: "body"
          }
        ].filter((s) => s != null);
      }
    },
    {
      name: "vitest:browser:support-testing-library",
      config() {
        return {
          optimizeDeps: {
            esbuildOptions: {
              plugins: [
                {
                  name: "test-utils-rewrite",
                  setup(build) {
                    build.onResolve({ filter: /^@vue\/test-utils$/ }, (args) => {
                      const _require2 = getRequire();
                      const resolved = _require2.resolve(args.path, {
                        paths: [args.importer]
                      });
                      return { path: resolved };
                    });
                  }
                }
              ]
            }
          }
        };
      }
    }
  ];
};
function tryResolve(path, paths) {
  try {
    const _require2 = getRequire();
    return _require2.resolve(path, { paths });
  } catch {
    return void 0;
  }
}
let _require;
function getRequire() {
  if (!_require) {
    _require = createRequire(import.meta.url);
  }
  return _require;
}
function resolveCoverageFolder(project) {
  const options = project.ctx.config;
  const htmlReporter = options.coverage?.enabled ? toArray(options.coverage.reporter).find((reporter) => {
    if (typeof reporter === "string") {
      return reporter === "html";
    }
    return reporter[0] === "html";
  }) : void 0;
  if (!htmlReporter) {
    return void 0;
  }
  const root = resolve(
    options.root || process.cwd(),
    options.coverage.reportsDirectory || coverageConfigDefaults.reportsDirectory
  );
  const subdir = Array.isArray(htmlReporter) && htmlReporter.length > 1 && "subdir" in htmlReporter[1] ? htmlReporter[1].subdir : void 0;
  if (!subdir || typeof subdir !== "string") {
    return [root, `/${basename(root)}/`];
  }
  return [resolve(root, subdir), `/${basename(root)}/${subdir}/`];
}
const postfixRE = /[?#].*$/;
function cleanUrl(url) {
  return url.replace(postfixRE, "");
}

const DEFAULT_TIMEOUT = 6e4;
function defaultSerialize(i) {
  return i;
}
const defaultDeserialize = defaultSerialize;
const { clearTimeout, setTimeout } = globalThis;
const random = Math.random.bind(Math);
function createBirpc(functions, options) {
  const {
    post,
    on,
    off = () => {
    },
    eventNames = [],
    serialize = defaultSerialize,
    deserialize = defaultDeserialize,
    resolver,
    bind = "rpc",
    timeout = DEFAULT_TIMEOUT
  } = options;
  const rpcPromiseMap = /* @__PURE__ */ new Map();
  let _promise;
  let closed = false;
  const rpc = new Proxy({}, {
    get(_, method) {
      if (method === "$functions")
        return functions;
      if (method === "$close")
        return close;
      if (method === "then" && !eventNames.includes("then") && !("then" in functions))
        return void 0;
      const sendEvent = (...args) => {
        post(serialize({ m: method, a: args, t: "q" }));
      };
      if (eventNames.includes(method)) {
        sendEvent.asEvent = sendEvent;
        return sendEvent;
      }
      const sendCall = async (...args) => {
        if (closed)
          throw new Error(`[birpc] rpc is closed, cannot call "${method}"`);
        if (_promise) {
          try {
            await _promise;
          } finally {
            _promise = void 0;
          }
        }
        return new Promise((resolve, reject) => {
          const id = nanoid();
          let timeoutId;
          if (timeout >= 0) {
            timeoutId = setTimeout(() => {
              try {
                options.onTimeoutError?.(method, args);
                throw new Error(`[birpc] timeout on calling "${method}"`);
              } catch (e) {
                reject(e);
              }
              rpcPromiseMap.delete(id);
            }, timeout);
            if (typeof timeoutId === "object")
              timeoutId = timeoutId.unref?.();
          }
          rpcPromiseMap.set(id, { resolve, reject, timeoutId, method });
          post(serialize({ m: method, a: args, i: id, t: "q" }));
        });
      };
      sendCall.asEvent = sendEvent;
      return sendCall;
    }
  });
  function close() {
    closed = true;
    rpcPromiseMap.forEach(({ reject, method }) => {
      reject(new Error(`[birpc] rpc is closed, cannot call "${method}"`));
    });
    rpcPromiseMap.clear();
    off(onMessage);
  }
  async function onMessage(data, ...extra) {
    const msg = deserialize(data);
    if (msg.t === "q") {
      const { m: method, a: args } = msg;
      let result, error;
      const fn = resolver ? resolver(method, functions[method]) : functions[method];
      if (!fn) {
        error = new Error(`[birpc] function "${method}" not found`);
      } else {
        try {
          result = await fn.apply(bind === "rpc" ? rpc : functions, args);
        } catch (e) {
          error = e;
        }
      }
      if (msg.i) {
        if (error && options.onError)
          options.onError(error, method, args);
        post(serialize({ t: "s", i: msg.i, r: result, e: error }), ...extra);
      }
    } else {
      const { i: ack, r: result, e: error } = msg;
      const promise = rpcPromiseMap.get(ack);
      if (promise) {
        clearTimeout(promise.timeoutId);
        if (error)
          promise.reject(error);
        else
          promise.resolve(result);
      }
      rpcPromiseMap.delete(ack);
    }
  }
  _promise = on(onMessage);
  return rpc;
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
function nanoid(size = 21) {
  let id = "";
  let i = size;
  while (i--)
    id += urlAlphabet[random() * 64 | 0];
  return id;
}

const debug$1 = createDebugger("vitest:browser:api");
const BROWSER_API_PATH = "/__vitest_browser_api__";
function setupBrowserRpc(server) {
  const project = server.project;
  const vite = server.vite;
  const ctx = project.ctx;
  const wss = new WebSocketServer({ noServer: true });
  vite.httpServer?.on("upgrade", (request, socket, head) => {
    if (!request.url) {
      return;
    }
    const { pathname, searchParams } = new URL(request.url, "http://localhost");
    if (pathname !== BROWSER_API_PATH) {
      return;
    }
    if (!isValidApiRequest(ctx.config, request)) {
      socket.destroy();
      return;
    }
    const type = searchParams.get("type") ?? "tester";
    const sessionId = searchParams.get("sessionId") ?? "0";
    wss.handleUpgrade(request, socket, head, (ws) => {
      wss.emit("connection", ws, request);
      const rpc = setupClient(sessionId, ws);
      const state = server.state;
      const clients = type === "tester" ? state.testers : state.orchestrators;
      clients.set(sessionId, rpc);
      debug$1?.("[%s] Browser API connected to %s", sessionId, type);
      ws.on("close", () => {
        debug$1?.("[%s] Browser API disconnected from %s", sessionId, type);
        clients.delete(sessionId);
        server.state.removeCDPHandler(sessionId);
      });
    });
  });
  function checkFileAccess(path) {
    if (!isFileServingAllowed(path, vite)) {
      throw new Error(
        `Access denied to "${path}". See Vite config documentation for "server.fs": https://vitejs.dev/config/server-options.html#server-fs-strict.`
      );
    }
  }
  function setupClient(sessionId, ws) {
    const mockResolver = new ServerMockResolver(server.vite, {
      moduleDirectories: project.config.server?.deps?.moduleDirectories
    });
    const rpc = createBirpc(
      {
        async onUnhandledError(error, type) {
          if (error && typeof error === "object") {
            const _error = error;
            _error.stacks = server.parseErrorStacktrace(_error);
          }
          ctx.state.catchError(error, type);
        },
        async onCollected(files) {
          ctx.state.collectFiles(project, files);
          await ctx.report("onCollected", files);
        },
        async onTaskUpdate(packs) {
          ctx.state.updateTasks(packs);
          await ctx.report("onTaskUpdate", packs);
        },
        onAfterSuiteRun(meta) {
          ctx.coverageProvider?.onAfterSuiteRun(meta);
        },
        sendLog(log) {
          return ctx.report("onUserConsoleLog", log);
        },
        resolveSnapshotPath(testPath) {
          return ctx.snapshot.resolvePath(testPath);
        },
        resolveSnapshotRawPath(testPath, rawPath) {
          return ctx.snapshot.resolveRawPath(testPath, rawPath);
        },
        snapshotSaved(snapshot) {
          ctx.snapshot.add(snapshot);
        },
        async readSnapshotFile(snapshotPath) {
          checkFileAccess(snapshotPath);
          if (!existsSync(snapshotPath)) {
            return null;
          }
          return promises.readFile(snapshotPath, "utf-8");
        },
        async saveSnapshotFile(id, content) {
          checkFileAccess(id);
          await promises.mkdir(dirname(id), { recursive: true });
          return promises.writeFile(id, content, "utf-8");
        },
        async removeSnapshotFile(id) {
          checkFileAccess(id);
          if (!existsSync(id)) {
            throw new Error(`Snapshot file "${id}" does not exist.`);
          }
          return promises.unlink(id);
        },
        getBrowserFileSourceMap(id) {
          const mod = server.vite.moduleGraph.getModuleById(id);
          return mod?.transformResult?.map;
        },
        onCancel(reason) {
          ctx.cancelCurrentRun(reason);
        },
        async resolveId(id, importer) {
          return mockResolver.resolveId(id, importer);
        },
        debug(...args) {
          ctx.logger.console.debug(...args);
        },
        getCountOfFailedTests() {
          return ctx.state.getCountOfFailedTests();
        },
        async triggerCommand(contextId, command, testPath, payload) {
          debug$1?.('[%s] Triggering command "%s"', contextId, command);
          const provider = server.provider;
          if (!provider) {
            throw new Error("Commands are only available for browser tests.");
          }
          const commands = project.config.browser?.commands;
          if (!commands || !commands[command]) {
            throw new Error(`Unknown command "${command}".`);
          }
          if (provider.beforeCommand) {
            await provider.beforeCommand(command, payload);
          }
          const context = Object.assign(
            {
              testPath,
              project,
              provider,
              contextId
            },
            provider.getCommandsContext(contextId)
          );
          let result;
          try {
            result = await commands[command](context, ...payload);
          } finally {
            if (provider.afterCommand) {
              await provider.afterCommand(command, payload);
            }
          }
          return result;
        },
        finishBrowserTests(contextId) {
          debug$1?.("[%s] Finishing browser tests for context", contextId);
          return server.state.getContext(contextId)?.resolve();
        },
        resolveMock(rawId, importer, options) {
          return mockResolver.resolveMock(rawId, importer, options);
        },
        invalidate(ids) {
          return mockResolver.invalidate(ids);
        },
        // CDP
        async sendCdpEvent(contextId, event, payload) {
          const cdp = await server.ensureCDPHandler(contextId, sessionId);
          return cdp.send(event, payload);
        },
        async trackCdpEvent(contextId, type, event, listenerId) {
          const cdp = await server.ensureCDPHandler(contextId, sessionId);
          cdp[type](event, listenerId);
        }
      },
      {
        post: (msg) => ws.send(msg),
        on: (fn) => ws.on("message", fn),
        eventNames: ["onCancel", "cdpEvent"],
        serialize: (data) => stringify(data, stringifyReplace),
        deserialize: parse,
        onTimeoutError(functionName) {
          throw new Error(`[vitest-api]: Timeout calling "${functionName}"`);
        }
      }
    );
    ctx.onCancel((reason) => rpc.onCancel(reason));
    return rpc;
  }
}
function cloneByOwnProperties(value) {
  return Object.getOwnPropertyNames(value).reduce(
    (clone, prop) => ({
      ...clone,
      [prop]: value[prop]
    }),
    {}
  );
}
function stringifyReplace(key, value) {
  if (value instanceof Error) {
    const cloned = cloneByOwnProperties(value);
    return {
      name: value.name,
      message: value.message,
      stack: value.stack,
      ...cloned
    };
  } else {
    return value;
  }
}

class BrowserServerCDPHandler {
  constructor(session, tester) {
    this.session = session;
    this.tester = tester;
  }
  listenerIds = {};
  listeners = {};
  send(method, params) {
    return this.session.send(method, params);
  }
  on(event, id, once = false) {
    if (!this.listenerIds[event]) {
      this.listenerIds[event] = [];
    }
    this.listenerIds[event].push(id);
    if (!this.listeners[event]) {
      this.listeners[event] = (payload) => {
        this.tester.cdpEvent(
          event,
          payload
        );
        if (once) {
          this.off(event, id);
        }
      };
      this.session.on(event, this.listeners[event]);
    }
  }
  off(event, id) {
    if (!this.listenerIds[event]) {
      this.listenerIds[event] = [];
    }
    this.listenerIds[event] = this.listenerIds[event].filter((l) => l !== id);
    if (!this.listenerIds[event].length) {
      this.session.off(event, this.listeners[event]);
      delete this.listeners[event];
    }
  }
  once(event, listener) {
    this.on(event, listener, true);
  }
}

class BrowserServerState {
  orchestrators = /* @__PURE__ */ new Map();
  testers = /* @__PURE__ */ new Map();
  cdps = /* @__PURE__ */ new Map();
  contexts = /* @__PURE__ */ new Map();
  getContext(contextId) {
    return this.contexts.get(contextId);
  }
  createAsyncContext(method, contextId, files) {
    const defer = createDefer();
    this.contexts.set(contextId, {
      files,
      method,
      resolve: () => {
        defer.resolve();
        this.contexts.delete(contextId);
      },
      reject: defer.reject
    });
    return defer;
  }
  async removeCDPHandler(sessionId) {
    this.cdps.delete(sessionId);
  }
}

class BrowserServer {
  constructor(project, base) {
    this.project = project;
    this.base = base;
    this.stackTraceOptions = {
      frameFilter: project.config.onStackTrace,
      getSourceMap: (id) => {
        const result = this.vite.moduleGraph.getModuleById(id)?.transformResult;
        return result?.map;
      },
      getFileName: (id) => {
        const mod = this.vite.moduleGraph.getModuleById(id);
        if (mod?.file) {
          return mod.file;
        }
        const modUrl = this.vite.moduleGraph.urlToModuleMap.get(id);
        if (modUrl?.file) {
          return modUrl.file;
        }
        return id;
      }
    };
    this.state = new BrowserServerState();
    const pkgRoot = resolve(fileURLToPath(import.meta.url), "../..");
    const distRoot = resolve(pkgRoot, "dist");
    this.prefixTesterUrl = `${base}__vitest_test__/__test__/`;
    this.faviconUrl = `${base}__vitest__/favicon.svg`;
    this.manifest = (async () => {
      return JSON.parse(
        await readFile$1(`${distRoot}/client/.vite/manifest.json`, "utf8")
      );
    })().then((manifest) => this.manifest = manifest);
    const testerHtmlPath = project.config.browser.testerHtmlPath ? resolve(project.config.root, project.config.browser.testerHtmlPath) : resolve(distRoot, "client/tester/tester.html");
    if (!existsSync(testerHtmlPath)) {
      throw new Error(`Tester HTML file "${testerHtmlPath}" doesn't exist.`);
    }
    this.testerFilepath = testerHtmlPath;
    this.testerHtml = readFile$1(
      testerHtmlPath,
      "utf8"
    ).then((html) => this.testerHtml = html);
    this.orchestratorHtml = (project.config.browser.ui ? readFile$1(resolve(distRoot, "client/__vitest__/index.html"), "utf8") : readFile$1(resolve(distRoot, "client/orchestrator.html"), "utf8")).then((html) => this.orchestratorHtml = html);
    this.injectorJs = readFile$1(
      resolve(distRoot, "client/esm-client-injector.js"),
      "utf8"
    ).then((js) => this.injectorJs = js);
    this.errorCatcherUrl = join("/@fs/", resolve(distRoot, "client/error-catcher.js"));
    const builtinProviders = ["playwright", "webdriverio", "preview"];
    const providerName = project.config.browser.provider || "preview";
    if (builtinProviders.includes(providerName)) {
      this.locatorsUrl = join("/@fs/", distRoot, "locators", `${providerName}.js`);
    }
    this.stateJs = readFile$1(
      resolve(distRoot, "state.js"),
      "utf-8"
    ).then((js) => this.stateJs = js);
  }
  faviconUrl;
  prefixTesterUrl;
  orchestratorScripts;
  testerScripts;
  manifest;
  testerHtml;
  testerFilepath;
  orchestratorHtml;
  injectorJs;
  errorCatcherUrl;
  locatorsUrl;
  stateJs;
  state;
  provider;
  vite;
  stackTraceOptions;
  setServer(server) {
    this.vite = server;
  }
  getSerializableConfig() {
    const config = wrapConfig(this.project.getSerializableConfig());
    config.env ??= {};
    config.env.VITEST_BROWSER_DEBUG = process.env.VITEST_BROWSER_DEBUG || "";
    return config;
  }
  resolveTesterUrl(pathname) {
    const [contextId, testFile] = pathname.slice(this.prefixTesterUrl.length).split("/");
    const decodedTestFile = decodeURIComponent(testFile);
    return { contextId, testFile: decodedTestFile };
  }
  async formatScripts(scripts) {
    if (!scripts?.length) {
      return [];
    }
    const server = this.vite;
    const promises = scripts.map(
      async ({ content, src, async, id, type = "module" }, index) => {
        const srcLink = (src ? (await server.pluginContainer.resolveId(src))?.id : void 0) || src;
        const transformId = srcLink || join(server.config.root, `virtual__${id || `injected-${index}.js`}`);
        await server.moduleGraph.ensureEntryFromUrl(transformId);
        const contentProcessed = content && type === "module" ? (await server.pluginContainer.transform(content, transformId)).code : content;
        return {
          tag: "script",
          attrs: {
            type,
            ...async ? { async: "" } : {},
            ...srcLink ? {
              src: srcLink.startsWith("http") ? srcLink : slash(`/@fs/${srcLink}`)
            } : {}
          },
          injectTo: "head",
          children: contentProcessed || ""
        };
      }
    );
    return await Promise.all(promises);
  }
  async initBrowserProvider() {
    if (this.provider) {
      return;
    }
    const Provider = await getBrowserProvider(this.project.config.browser, this.project);
    this.provider = new Provider();
    const browser = this.project.config.browser.name;
    if (!browser) {
      throw new Error(
        `[${this.project.getName()}] Browser name is required. Please, set \`test.browser.name\` option manually.`
      );
    }
    const supportedBrowsers = this.provider.getSupportedBrowsers();
    if (supportedBrowsers.length && !supportedBrowsers.includes(browser)) {
      throw new Error(
        `[${this.project.getName()}] Browser "${browser}" is not supported by the browser provider "${this.provider.name}". Supported browsers: ${supportedBrowsers.join(", ")}.`
      );
    }
    const providerOptions = this.project.config.browser.providerOptions;
    await this.provider.initialize(this.project, {
      browser,
      options: providerOptions
    });
  }
  parseErrorStacktrace(e, options = {}) {
    return parseErrorStacktrace(e, {
      ...this.stackTraceOptions,
      ...options
    });
  }
  parseStacktrace(trace, options = {}) {
    return parseStacktrace(trace, {
      ...this.stackTraceOptions,
      ...options
    });
  }
  cdpSessionsPromises = /* @__PURE__ */ new Map();
  async ensureCDPHandler(contextId, sessionId) {
    const cachedHandler = this.state.cdps.get(sessionId);
    if (cachedHandler) {
      return cachedHandler;
    }
    const provider = this.provider;
    if (!provider.getCDPSession) {
      throw new Error(`CDP is not supported by the provider "${provider.name}".`);
    }
    const promise = this.cdpSessionsPromises.get(sessionId) ?? await (async () => {
      const promise2 = provider.getCDPSession(contextId).finally(() => {
        this.cdpSessionsPromises.delete(sessionId);
      });
      this.cdpSessionsPromises.set(sessionId, promise2);
      return promise2;
    })();
    const session = await promise;
    const rpc = this.state.testers.get(sessionId);
    if (!rpc) {
      throw new Error(`Tester RPC "${sessionId}" was not established.`);
    }
    const handler = new BrowserServerCDPHandler(session, rpc);
    this.state.cdps.set(
      sessionId,
      handler
    );
    return handler;
  }
  async close() {
    await this.vite.close();
  }
}
function wrapConfig(config) {
  return {
    ...config,
    // workaround RegExp serialization
    testNamePattern: config.testNamePattern ? config.testNamePattern.toString() : void 0
  };
}

const debug = createDebugger("vitest:browser:pool");
async function waitForTests(method, contextId, project, files) {
  const context = project.browser.state.createAsyncContext(method, contextId, files);
  return await context;
}
function createBrowserPool(ctx) {
  const providers = /* @__PURE__ */ new Set();
  const executeTests = async (method, project, files) => {
    ctx.state.clearFiles(project, files);
    const browser = project.browser;
    const threadsCount = getThreadsCount(project);
    const provider = browser.provider;
    providers.add(provider);
    const resolvedUrls = browser.vite.resolvedUrls;
    const origin = resolvedUrls?.local[0] ?? resolvedUrls?.network[0];
    if (!origin) {
      throw new Error(
        `Can't find browser origin URL for project "${project.getName()}" when running tests for files "${files.join('", "')}"`
      );
    }
    async function setBreakpoint(contextId, file) {
      if (!project.config.inspector.waitForDebugger) {
        return;
      }
      if (!provider.getCDPSession) {
        throw new Error("Unable to set breakpoint, CDP not supported");
      }
      const session = await provider.getCDPSession(contextId);
      await session.send("Debugger.enable", {});
      await session.send("Debugger.setBreakpointByUrl", {
        lineNumber: 0,
        urlRegex: escapePathToRegexp(file)
      });
    }
    const filesPerThread = Math.ceil(files.length / threadsCount);
    const chunks = [];
    for (let i = 0; i < files.length; i += filesPerThread) {
      const chunk = files.slice(i, i + filesPerThread);
      chunks.push(chunk);
    }
    debug?.(
      `[%s] Running %s tests in %s chunks (%s threads)`,
      project.getName() || "core",
      files.length,
      chunks.length,
      threadsCount
    );
    const orchestrators = [...browser.state.orchestrators.entries()];
    const promises = [];
    chunks.forEach((files2, index) => {
      if (orchestrators[index]) {
        const [contextId, orchestrator] = orchestrators[index];
        debug?.(
          "Reusing orchestrator (context %s) for files: %s",
          contextId,
          [...files2.map((f) => relative(project.config.root, f))].join(", ")
        );
        const promise = waitForTests(method, contextId, project, files2);
        const tester = orchestrator.createTesters(files2).catch((error) => {
          if (error instanceof Error && error.message.startsWith("[birpc] rpc is closed")) {
            return;
          }
          return Promise.reject(error);
        });
        promises.push(promise, tester);
      } else {
        const contextId = crypto.randomUUID();
        const waitPromise = waitForTests(method, contextId, project, files2);
        debug?.(
          "Opening a new context %s for files: %s",
          contextId,
          [...files2.map((f) => relative(project.config.root, f))].join(", ")
        );
        const url = new URL("/", origin);
        url.searchParams.set("contextId", contextId);
        const page = provider.openPage(contextId, url.toString(), () => setBreakpoint(contextId, files2[0]));
        promises.push(page, waitPromise);
      }
    });
    await Promise.all(promises);
  };
  const runWorkspaceTests = async (method, specs) => {
    const groupedFiles = /* @__PURE__ */ new Map();
    for (const [project, file] of specs) {
      const files = groupedFiles.get(project) || [];
      files.push(file);
      groupedFiles.set(project, files);
    }
    let isCancelled = false;
    ctx.onCancel(() => {
      isCancelled = true;
    });
    for (const [project, files] of groupedFiles.entries()) {
      if (isCancelled) {
        break;
      }
      await project.initBrowserProvider();
      await executeTests(method, project, files);
    }
  };
  const numCpus = typeof nodeos.availableParallelism === "function" ? nodeos.availableParallelism() : nodeos.cpus().length;
  function getThreadsCount(project) {
    const config = project.config.browser;
    if (!config.headless || !project.browser.provider.supportsParallelism) {
      return 1;
    }
    if (!config.fileParallelism) {
      return 1;
    }
    return ctx.config.watch ? Math.max(Math.floor(numCpus / 2), 1) : Math.max(numCpus - 1, 1);
  }
  return {
    name: "browser",
    async close() {
      await Promise.all([...providers].map((provider) => provider.close()));
      providers.clear();
      ctx.resolvedProjects.forEach((project) => {
        project.browser?.state.orchestrators.forEach((orchestrator) => {
          orchestrator.$close();
        });
      });
    },
    runTests: (files) => runWorkspaceTests("run", files),
    collectTests: (files) => runWorkspaceTests("collect", files)
  };
}
function escapePathToRegexp(path) {
  return path.replace(/[/\\.?*()^${}|[\]+]/g, "\\$&");
}

async function createBrowserServer(project, configFile, prePlugins = [], postPlugins = []) {
  if (project.ctx.version !== version) {
    project.ctx.logger.warn(
      c.yellow(
        `Loaded ${c.inverse(c.yellow(` vitest@${project.ctx.version} `))} and ${c.inverse(c.yellow(` @vitest/browser@${version} `))}.
Running mixed versions is not supported and may lead into bugs
Update your dependencies and make sure the versions match.`
      )
    );
  }
  const server = new BrowserServer(project, "/");
  const configPath = typeof configFile === "string" ? configFile : false;
  const logLevel = process.env.VITEST_BROWSER_DEBUG ?? "info";
  const logger = createViteLogger(project.logger, logLevel, {
    allowClearScreen: false
  });
  const vite = await createViteServer({
    ...project.options,
    // spread project config inlined in root workspace config
    base: "/",
    logLevel,
    customLogger: {
      ...logger,
      info(msg, options) {
        logger.info(msg, options);
        if (msg.includes("optimized dependencies changed. reloading")) {
          logger.warn(
            [
              c.yellow(`
${c.bold("[vitest]")} Vite unexpectedly reloaded a test. This may cause tests to fail, lead to flaky behaviour or duplicated test runs.
`),
              c.yellow(`For a stable experience, please add mentioned dependencies to your config's ${c.bold("`optimizeDeps.include`")} field manually.

`)
            ].join("")
          );
        }
      }
    },
    mode: project.config.mode,
    configFile: configPath,
    // watch is handled by Vitest
    server: {
      hmr: false,
      watch: null
    },
    plugins: [
      ...prePlugins,
      ...project.options?.plugins || [],
      BrowserPlugin(server),
      ...postPlugins
    ]
  });
  await vite.listen();
  setupBrowserRpc(server);
  return server;
}

export { createBrowserPool, createBrowserServer, distRoot };
